---
layout: post
title: Week 1
---

Day 1: 12/8

  Made roll dice function and score calculator. The roll dice function was copy and paste from a previous mission, which is always a great way to start (I was expecially happy because this meant I wouldn't have to create any doc string). The score calculator also had some simularities to the previous Yahtzee simulator, however, there are some different scoring rules that made things more difficult (for example, a full house and two three of a kind are scored differently). I needed my function to be able to score a rolls with the number of dice ranging from 1 to 6, so I used some if-else logic to eliminate scoring based on the number of dice. After some effort, I discovered the previous logic used for the Yahtzee simulator does not apply well in this function, so I had to switch my approach, which was a little fusterating. I instead made a dictionary that counted the number if appearances of each dice face, and then manipulated that to complete the score function.


Day 2: 12/9

  Made basic interactive game simulator and built a shell for the game optimizer function. Creating the game player was a lot more fun and intertaining, and a lot more rewarding since in the end I had something that was kind of fun and that I could show off. In addition, the game play function ran without errors and was pretty straightfoward, yet already I have a farkle simulator. The optimize game took a lot more effert to logic out it's interaction with the game play function, even if it always returns bank all by returning all of the bankable dice. Setting up the dictionary in the score function above definitely made my life easier here, so I kind of gave myself a pat on the back for that one.


Day 3: 12/10

  I updated all the blog for the first time! I also spent some time logicing out the optimizing function and checking out numpy and scipy modules for probablity.


Day 4: 12/12

  Started logicing through the optimal game play functions. I ended up having to change the scoring function to make the optimizer functions easier to mess with by returning a dictionary rather then a list of bankable dice, and then I wrote a bunch of test cases. And then I ended up changing it again! And had to rewrite test cases for the third time. Not very fun and very mudane, but I think it will make life easier in the long run. I also set up another functions and took farkle stats to help with the optimal game play functions. It also was a good way to check that everything was working, because some farkle stats are already out there on the internet from other people so checking that mine match is a good checker.


Day 5: 12/13

  I figured out that the stats weren't cctually accurate because it was only counting after one more roll, when in reality the average score of four dice includes banking and then rolling three more so I tried to fix my function up so it would keep playing. Then I figured out that in order to get the stats to make my should roll function, I needed to have my to roll function and what to bank functions established (optimal play decider functions). It was a rather interesting phenomonon that I found rather interesting: as I would make basic optimal play functions and the use that to get stats and then update my functions and then get stats and it was almost an endless cycle.


Day 6: 12/14

  My extended family plays some traditional games of Farkle every year and we we used excel to record everything, and all of the stats of each play and farkle rates and number of turns and average score was already set up so I got a nice data set for free. Awesome! I also set up a lot of different version of my optimal play functions and tested each of them out by making a bunch of other functions to not only play a round but a whole game. The best version will have the least avergae number of turns to win. One version I did got down to 18 turns, which is the same if not slightly better then real person play! However, then I discovered a fault in my playing functions, where it was addiding to the score all of the possible bankable dice while not actually banking all of the dice, and basically getting extra points. At that point my functions where running at about 20 turns average to win. Which was kind of sad. I did a bunch of iterating and thinking and then went through the internet to see what people said the optimal stradegy is. There was one really series research group formal paper that had a bunch of math and defined some stradegy. The functions I set up actually matched alot of there stuff, as far as variables and what data was taken and etc, although there game play is also dependent on other peoples score and your score, to decide safe or risky play. However, their optimal player only had a 1% greater chance of winning then the average human. Which is a tad bit disappointing. In addition, as far as how the optimal player works, it really was not helpful for me, and is addition their rules differed slightly from the game play rules we follow.


Day 7: 12/15

  Still working on those optimal play functions. Instead of running the function a million times with all the different combinations of my different versions to see which version preforms the best, I created a bar graph that graphs the average turns and runs through every possible combination with every one of the functions. Now I realize that I probably didn't need the graph and could have printed it out, in order, but too late. I tried all of the different stradegies I could think of but I still wasn't getting great results so I tried to go a different stradegy. I did a bit of research and then figured out that you could, in google colab, create a little AI bot that would try out all of the different things and edit itself until it became the best version (define positive and negative feedback and etc.) I spent a solid chunk of time figuring that out and then figured out that I've really jumped off of the rails. I then started working on possible making a GUI since I felt stuck on the optimal play functions. The true way to figure out optimal play is to create a giant decision tree and total the points with the probabilities to figure out the best banking option (should roll function I'm feeling OK about) but that seems a bit impossible, definitely given the time constraits.


Day 8: 12/16

  I got rid of the graph and I finished my optimal play simulator thingamabob, so I started making my tree! The optimal function thingy actual ended up getting me pretty good results, I was really worried because after I did my research it said that the optimal player has only a 1% greater chance of winning, and that was quite depressing. But I still finished all of my optimal play function and based off the stats from my families play it wins 36% of the time in a game of abour size people, which is 20% better then everybody else (assuming everybody else doesn't play farkle well). I was hoping for 100% turn out but this is pretty good! Plus I was able to plug it into my actual game playing function and make it interactive so that it lets you write in the choice you would make and then it provides feedback. And it actually works! It took me a minute to get the input formatted, for somereason I though that you could just type in a list with the input thingy (you can't) and it was giving me some errors that I interpreted as coming from someplace else (it wasn't) but it wasn't too difficult of a fix. When I was going through my different versions of the function and testing it out it turned out that some of my version while having different code where actually doing the same thing, and then I went up and saw they they where preforming the same to about 1%. It hurt a little bit to have to delete it but luckily the functions where mostly copy and paste, so it wasn't a huge loss of time. My results where also matching my predictions, which is great because they weren't quite doing it before.


Day 9: 12/17

  Since I'm pretty much done, I decided to try and make a tree. To start off I am not going do the rolls, but just each of the different banking possibilities. I am super (way too) famililar with trees from my other cs class, so setting up the tree wasn't difficult. It actual was almost copy and paste from something else I had to do, which made life way easier. I only added/adjusted a few attributes for my node class and then I was ready to go, so I started working through the tree building function and then figured out that I needed to make a function that returns all of the possible bankable combinations. This function was absolutely not fun, and really just increadibly annoying. I had my scoring function that returned a dictionary with each of the scoring catagory and then the dice that fit into that scoring category, so I figured that I could just build off of that. One problem though!!! The singles, 1's and 5's are grouped under one key, but for bankable combinations, I need to have it all seperated. I ran by head against that wall for a solid amount of time, before I had to completely change my approach, which was a bit fusterating. Since it is a dictionary, it would be more work to store each single under a different key I figured.and then my dictionary would have a bunch of keys that would be harder to iterate through. So instead I did some preprossesing and then iterated through every combination using my dice list and slicing and some of the funkiest iteration. However, then, my bankable combinations was returning a bunch of combos that split up multiples of a kind, adding a bunch of extra things to my return list that would really bog down my tree later on. I felt a bit stuck on that again, but then I figured that I could use the previous scoring function and take the dice out of that, eliminating the extra dices.

  
Day 10: 12/18

  I got a tree working! I finished off my build tree function without any problems except the error "removing things from empty list" or something along that lines, and I went the long way around of trying to ensure that the list was not empty, and then I realized that I just needed to create a shallow copy of it! (I gave myself a pat on the back for that one). After that, I created a function to print the tree by indending each node by it's depth, and then it worked! I printed a tree! It was quite a glorious day, although the tree is just with the different bankable combinations. I figured I didn't have time to tackle the rerolling aspect of farkle to create the actual tree, so I just added the rolling over aspect, which was actually super easy, you just had to reroll and make the rerolled dice the remaining dice. However, after that, I ended up with some absolutely massive trees, and I figured I needed to limit the depth of my tree. Going back to my original play when the tree included rolling, I added the probability attribute to my class. However, instead of doing the actual probability of rolling that I just decreased it with everylayer, but at least I have it set up now if I want to actual do all of the rolling and probability and calculating. Honestly, I think if in the begaining I did a tree, I would have been able to complete it and use it for the decision making functions. One I added probability, I set a threshold and then simular to farkling I set that threshold as a base case for building my tree. But as of this moment everything is working, and I think that my project is a good demonstration of the amout of hours I put into it. Here is the link to my final product! https://colab.research.google.com/drive/1q9Ci0-SNaaG3rJFiz_l66eNezzf3Cwa6?usp=sharing
