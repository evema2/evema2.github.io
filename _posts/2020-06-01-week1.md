---
layout: post
title: Week 1
---

Day 1: 12/8
  Made roll dice function and score calculator. The roll dice function was copy and paste from a previous mission, which is always a great way to start (I was expecially happy because this meant I wouldn't have to create any doc string). The score calculator also had some simularities to the previous Yahtzee simulator, however, there are some different scoring rules that made things more difficult (for example, a full house and two three of a kind are scored differently). I needed my function to be able to score a rolls with the number of dice ranging from 1 to 6, so I used some if-else logic to eliminate scoring based on the number of dice. After some effort, I discovered the previous logic used for the Yahtzee simulator does not apply well in this function, so I had to switch my approach, which was a little fusterating. I instead made a dictionary that counted the number if appearances of each dice face, and then manipulated that to complete the score function.

Day 2: 12/9
  Made basic interactive game simulator and built a shell for the game optimizer function. Creating the game player was a lot more fun and intertaining, and a lot more rewarding since in the end I had something that was kind of fun and that I could show off. In addition, the game play function ran without errors and was pretty straightfoward, yet already I have a farkle simulator. The optimize game took a lot more effert to logic out it's interaction with the game play function, even if it always returns bank all by returning all of the bankable dice. Setting up the dictionary in the score function above definitely made my life easier here, so I kind of gave myself a pat on the back for that one.

Day 3: 12/10
  I updated all the blog for the first time! I also spent some time logicing out the optimizing function and checking out numpy and scipy modules for probablity.

Day 4: 12/12
  Started logicing through the optimal game play functions. I ended up having to change the scoring function to make the optimizer functions easier to mess with by returning a dictionary rather then a list of bankable dice, and then I wrote a bunch of test cases. And then I ended up changing it again! And had to rewrite test cases for the third time. Not very fun and very mudane, but I think it will make life easier in the long run. I also set up another functions and took farkle stats to help with the optimal game play functions. It also was a good way to check that everything was working, because some farkle stats are already out there on the internet from other people so checking that mine match is a good checker.

Day 5: 12/13
  I figured out that the stats weren't cctually accurate because it was only counting after one more roll, when in reality the average score of four dice includes banking and then rolling three more so I tried to fix my function up so it would keep playing. Then I figured out that in order to get the stats to make my should roll function, I needed to have my to roll function and what to bank functions established (optimal play decider functions). It was a rather interesting phenomonon that I found rather interesting: as I would make basic optimal play functions and the use that to get stats and then update my functions and then get stats and it was almost an endless cycle.

Day 6: 12/14
  My extended family plays some traditional games of Farkle every year and we we used excel to record everything, and all of the stats of each play and farkle rates and number of turns and average score was already set up so I got a nice data set for free. Awesome! I also set up a lot of different version of my optimal play functions and tested each of them out by making a bunch of other functions to not only play a round but a whole game. The best version will have the least avergae number of turns to win. One version I did got down to 18 turns, which is the same if not slightly better then real person play! However, then I discovered a fault in my playing functions, where it was addiding to the score all of the possible bankable dice while not actually banking all of the dice, and basically getting extra points. At that point my functions where running at about 20 turns average to win. Which was kind of sad. I did a bunch of iterating and thinking and then went through the internet to see what people said the optimal stradegy is. There was one really series research group formal paper that had a bunch of math and defined some stradegy. The functions I set up actually matched alot of there stuff, as far as variables and what data was taken and etc, although there game play is also dependent on other peoples score and your score, to decide safe or risky play. However, their optimal player only had a 1% greater chance of winning then the average human. Which is a tad bit disappointing. In addition, as far as how the optimal player works, it really was not helpful for me, and is addition their rules differed slightly from the game play rules we follow.

Day 7: 12/15
  Still working on those optimal play functions. Instead of running the function a million times with all the different combinations of my different versions to see which version preforms the best, I created a bar graph that graphs the average turns and runs through every possible combination with every one of the functions. Now I realize that I probably didn't need the graph and could have printed it out, in order, but too late. I tried all of the different stradegies I could think of but I still wasn't getting great results so I tried to go a different stradegy. I did a bit of research and then figured out that you could, in google colab, create a little AI bot that would try out all of the different things and edit itself until it became the best version (define positive and negative feedback and etc.) I spent a solid chunk of time figuring that out and then figured out that I've really jumped off of the rails. I then started working on possible making a GUI since I felt stuck on the optimal play functions. The true way to figure out optimal play is to create a giant decision tree and total the points with the probabilities to figure out the best banking option (should roll function I'm feeling OK about) but that seems a bit impossible, definitely given the time constraits. 
